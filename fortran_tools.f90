module fortran_tools

  implicit none

  !! precomputed Lorentzian definite integrals relative to 0 (positive side only)
  real*8 :: dfine=0.01 ,minfine=0.0   !grid step and maximum value in units of FWHM, and 
  real*8 :: dmedium=0.1,minmedium=5.0 !grid step and maximum value in units of FWHM, and 
  real*8 :: dcoarse=1  ,mincoarse=50 ,maxcoarse=500 !grid step and maximum value in units of FWHM, and 
  real*8,dimension(501),parameter :: yfine=(/ 0.0, 0.0063653, 0.0127256, 0.0190757, 0.0254106, 0.0317254, 0.0380153, 0.0442755, 0.0505015, 0.0566887, 0.0628329, 0.0689300, 0.0749762, 0.0809678, 0.0869013, 0.0927735, 0.0985814, 0.1043223, 0.1099936, 0.1155932, 0.1211188, 0.1265688, 0.1319415, 0.1372356, 0.1424499, 0.1475835, 0.1526356, 0.1576057, 0.1624934, 0.1672984, 0.1720208, 0.1766605, 0.1812179, 0.1856933, 0.1900871, 0.1944000, 0.1986326, 0.2027857, 0.2068601, 0.2108567, 0.2147766, 0.2186207, 0.2223902, 0.2260862, 0.2297098, 0.2332622, 0.2367446, 0.2401584, 0.2435047, 0.2467848, &
       0.2499999, 0.2531514, 0.2562405, 0.2592684, 0.2622366, 0.2651461, 0.2679982, 0.2707943, 0.2735354, 0.2762229, 0.2788578, 0.2814415, 0.2839749, 0.2864593, 0.2888958, 0.2912855, 0.2936294, 0.2959287, 0.2981842, 0.3003971, 0.3025684, 0.3046989, 0.3067897, 0.3088417, 0.3108558, 0.3128329, 0.3147738, 0.3166793, 0.3185504, 0.3203878, 0.3221922, 0.3239645, 0.3257055, 0.3274157, 0.3290959, 0.3307469, 0.3323693, 0.3339637, 0.3355308, 0.3370712, 0.3385855, 0.3400743, 0.3415382, 0.3429777, 0.3443934, 0.3457858, 0.3471555, 0.3485029, 0.3498285, 0.3511328,   &
       0.3524163, 0.3536794, 0.3549226, 0.3561463, 0.3573510, 0.3585369, 0.3597046, 0.3608544, 0.3619867, 0.3631018, 0.3642002, 0.3652821, 0.3663480, 0.3673981, 0.3684328, 0.3694524, 0.3704571, 0.3714474, 0.3724234, 0.3733855, 0.3743340, 0.3752691, 0.3761911, 0.3771003, 0.3779968, 0.3788810, 0.3797531, 0.3806133, 0.3814618, 0.3822990, 0.3831249, 0.3839398, 0.3847439, 0.3855375, 0.3863207, 0.3870936, 0.3878566, 0.3886097, 0.3893532, 0.3900873, 0.3908120, 0.3915277, 0.3922343, 0.3929322, 0.3936214, 0.3943021, 0.3949745, 0.3956387, 0.3962949, 0.3969431,   &
       0.3975836, 0.3982164, 0.3988417, 0.3994596, 0.4000703, 0.4006739, 0.4012704, 0.4018600, 0.4024429, 0.4030191, 0.4035887, 0.4041519, 0.4047087, 0.4052593, 0.4058038, 0.4063422, 0.4068746, 0.4074013, 0.4079221, 0.4084373, 0.4089469, 0.4094511, 0.4099498, 0.4104432, 0.4109314, 0.4114144, 0.4118924, 0.4123653, 0.4128333, 0.4132965, 0.4137549, 0.4142086, 0.4146576, 0.4151021, 0.4155421, 0.4159777, 0.4164089, 0.4168358, 0.4172584, 0.4176769, 0.4180913, 0.4185016, 0.4189079, 0.4193102, 0.4197087, 0.4201033, 0.4204942, 0.4208813, 0.4212647, 0.4216446,   &
       0.4220208, 0.4223935, 0.4227628, 0.4231286, 0.4234911, 0.4238502, 0.4242060, 0.4245585, 0.4249079, 0.4252541, 0.4255972, 0.4259372, 0.4262741, 0.4266081, 0.4269391, 0.4272672, 0.4275924, 0.4279148, 0.4282343, 0.4285511, 0.4288651, 0.4291765, 0.4294851, 0.4297912, 0.4300946, 0.4303955, 0.4306938, 0.4309896, 0.4312829, 0.4315738, 0.4318623, 0.4321484, 0.4324322, 0.4327136, 0.4329927, 0.4332695, 0.4335441, 0.4338165, 0.4340867, 0.4343547, 0.4346206, 0.4348843, 0.4351460, 0.4354056, 0.4356632, 0.4359187, 0.4361723, 0.4364239, 0.4366735, 0.4369212,   &
       0.4371670, 0.4374109, 0.4376530, 0.4378932, 0.4381316, 0.4383682, 0.4386030, 0.4388360, 0.4390673, 0.4392969, 0.4395248, 0.4397510, 0.4399755, 0.4401984, 0.4404197, 0.4406393, 0.4408574, 0.4410738, 0.4412888, 0.4415021, 0.4417140, 0.4419243, 0.4421331, 0.4423405, 0.4425464, 0.4427508, 0.4429538, 0.4431554, 0.4433556, 0.4435544, 0.4437518, 0.4439478, 0.4441425, 0.4443359, 0.4445279, 0.4447187, 0.4449081, 0.4450963, 0.4452832, 0.4454688, 0.4456532, 0.4458364, 0.4460184, 0.4461991, 0.4463787, 0.4465570, 0.4467342, 0.4469102, 0.4470851, 0.4472589,   &
       0.4474315, 0.4476030, 0.4477734, 0.4479427, 0.4481109, 0.4482781, 0.4484441, 0.4486092, 0.4487731, 0.4489361, 0.4490980, 0.4492589, 0.4494188, 0.4495777, 0.4497357, 0.4498926, 0.4500486, 0.4502036, 0.4503577, 0.4505108, 0.4506630, 0.4508142, 0.4509646, 0.4511140, 0.4512625, 0.4514102, 0.4515569, 0.4517028, 0.4518478, 0.4519919, 0.4521352, 0.4522777, 0.4524193, 0.4525601, 0.4527000, 0.4528391, 0.4529775, 0.4531150, 0.4532517, 0.4533877, 0.4535228, 0.4536572, 0.4537908, 0.4539236, 0.4540557, 0.4541871, 0.4543176, 0.4544475, 0.4545766, 0.4547050,   &
       0.4548327, 0.4549597, 0.4550859, 0.4552115, 0.4553364, 0.4554605, 0.4555840, 0.4557068, 0.4558290, 0.4559505, 0.4560713, 0.4561914, 0.4563109, 0.4564298, 0.4565480, 0.4566656, 0.4567825, 0.4568988, 0.4570145, 0.4571296, 0.4572441, 0.4573580, 0.4574712, 0.4575839, 0.4576960, 0.4578075, 0.4579184, 0.4580287, 0.4581385, 0.4582477, 0.4583563, 0.4584644, 0.4585719, 0.4586788, 0.4587852, 0.4588911, 0.4589964, 0.4591012, 0.4592055, 0.4593092, 0.4594124, 0.4595151, 0.4596173, 0.4597189, 0.4598201, 0.4599207, 0.4600209, 0.4601205, 0.4602197, 0.4603183,   &
       0.4604165, 0.4605142, 0.4606114, 0.4607082, 0.4608045, 0.4609003, 0.4609956, 0.4610905, 0.4611849, 0.4612789, 0.4613724, 0.4614655, 0.4615581, 0.4616503, 0.4617420, 0.4618333, 0.4619242, 0.4620146, 0.4621047, 0.4621943, 0.4622834, 0.4623722, 0.4624605, 0.4625484, 0.4626360, 0.4627231, 0.4628098, 0.4628961, 0.4629820, 0.4630675, 0.4631526, 0.4632374, 0.4633217, 0.4634057, 0.4634893, 0.4635725, 0.4636553, 0.4637377, 0.4638198, 0.4639015, 0.4639829, 0.4640639, 0.4641445, 0.4642247, 0.4643046, 0.4643842, 0.4644634, 0.4645422, 0.4646207, 0.4646989,   &
       0.4647767, 0.4648541, 0.4649313, 0.4650080, 0.4650845, 0.4651606, 0.4652364, 0.4653119, 0.4653870, 0.4654619, 0.4655364, 0.4656105, 0.4656844, 0.4657579, 0.4658312, 0.4659041, 0.4659767, 0.4660490, 0.4661210, 0.4661927, 0.4662641, 0.4663352, 0.4664060, 0.4664765, 0.4665467, 0.4666166, 0.4666862, 0.4667555, 0.4668246, 0.4668933, 0.4669618, 0.4670300, 0.4670979, 0.4671656, 0.4672329, 0.4673000, 0.4673668, 0.4674334, 0.4674996, 0.4675656, 0.4676314, 0.4676969, 0.4677621, 0.4678270, 0.4678917, 0.4679561, 0.4680203, 0.4680842, 0.4681479, 0.4682113,0.4682744  /)
  real*8,dimension(451),parameter :: ymedium=(/ 0.46827448, 0.46889255, 0.46948708, 0.47005937, 0.47061065, 0.47114206, 0.47165463, 0.47214936, 0.47262716, 0.47308888, 0.47353532, 0.47396722, 0.47438528, 0.47479015, 0.47518244, 0.47556274, 0.47593158, 0.47628948, 0.47663690, 0.47697431, 0.47730212, 0.47762075, 0.47793057, 0.47823195, 0.47852521, 0.47881069, 0.47908869, 0.47935950, 0.47962339, 0.47988064, 0.48013147, 0.48037614, 0.48061486, 0.48084785, 0.48107531, 0.48129744, 0.48151442, 0.48172642, 0.48193363, 0.48213620, 0.48233427, 0.48252801, 0.48271755, 0.48290302, 0.48308456, 0.48326229, 0.48343632, 0.48360678, 0.48377376, 0.48393739, &
       0.48409774, 0.48425493, 0.48440905, 0.48456018, 0.48470841, 0.48485382, 0.48499650, 0.48513651, 0.48527394, 0.48540885, 0.48554132, 0.48567140, 0.48579916, 0.48592467, 0.48604798, 0.48616915, 0.48628823, 0.48640528, 0.48652035, 0.48663349, 0.48674475, 0.48685417, 0.48696180, 0.48706769, 0.48717187, 0.48727438, 0.48737527, 0.48747458, 0.48757233, 0.48766858, 0.48776334, 0.48785666, 0.48794856, 0.48803909, 0.48812827, 0.48821613, 0.48830269, 0.48838800, 0.48847207, 0.48855493, 0.48863661, 0.48871714, 0.48879653, 0.48887481, 0.48895201, 0.48902814, 0.48910323, 0.48917730, 0.48925037, 0.48932246, &
       0.48939359, 0.48946378, 0.48953305, 0.48960141, 0.48966889, 0.48973549, 0.48980125, 0.48986616, 0.48993026, 0.48999355, 0.49005605, 0.49011777, 0.49017873, 0.49023895, 0.49029843, 0.49035719, 0.49041525, 0.49047261, 0.49052928, 0.49058529, 0.49064064, 0.49069534, 0.49074941, 0.49080285, 0.49085568, 0.49090790, 0.49095953, 0.49101058, 0.49106106, 0.49111097, 0.49116033, 0.49120914, 0.49125742, 0.49130517, 0.49135240, 0.49139912, 0.49144534, 0.49149106, 0.49153630, 0.49158106, 0.49162535, 0.49166918, 0.49171255, 0.49175547, 0.49179795, 0.49183999, 0.49188161, 0.49192280, 0.49196357, 0.49200394, &
       0.49204391, 0.49208347, 0.49212265, 0.49216143, 0.49219984, 0.49223788, 0.49227554, 0.49231285, 0.49234979, 0.49238638, 0.49242262, 0.49245852, 0.49249408, 0.49252930, 0.49256420, 0.49259877, 0.49263303, 0.49266696, 0.49270059, 0.49273391, 0.49276692, 0.49279964, 0.49283207, 0.49286420, 0.49289604, 0.49292761, 0.49295889, 0.49298990, 0.49302063, 0.49305110, 0.49308130, 0.49311125, 0.49314093, 0.49317036, 0.49319954, 0.49322847, 0.49325715, 0.49328559, 0.49331380, 0.49334176, 0.49336950, 0.49339700, 0.49342428, 0.49345133, 0.49347816, 0.49350478, 0.49353117, 0.49355735, 0.49358333, 0.49360909, &
       0.49363465, 0.49366000, 0.49368515, 0.49371010, 0.49373486, 0.49375942, 0.49378380, 0.49380798, 0.49383197, 0.49385578, 0.49387941, 0.49390285, 0.49392612, 0.49394921, 0.49397212, 0.49399486, 0.49401743, 0.49403983, 0.49406207, 0.49408414, 0.49410604, 0.49412779, 0.49414937, 0.49417080, 0.49419207, 0.49421318, 0.49423414, 0.49425495, 0.49427561, 0.49429613, 0.49431649, 0.49433672, 0.49435679, 0.49437673, 0.49439653, 0.49441618, 0.49443570, 0.49445509, 0.49447434, 0.49449345, 0.49451244, 0.49453129, 0.49455002, 0.49456861, 0.49458708, 0.49460543, 0.49462365, 0.49464175, 0.49465973, 0.49467758, &
       0.49469532, 0.49471294, 0.49473045, 0.49474783, 0.49476511, 0.49478227, 0.49479932, 0.49481625, 0.49483308, 0.49484980, 0.49486641, 0.49488291, 0.49489931, 0.49491560, 0.49493179, 0.49494788, 0.49496387, 0.49497975, 0.49499553, 0.49501122, 0.49502681, 0.49504230, 0.49505769, 0.49507299, 0.49508820, 0.49510331, 0.49511832, 0.49513325, 0.49514809, 0.49516283, 0.49517749, 0.49519205, 0.49520653, 0.49522093, 0.49523523, 0.49524945, 0.49526359, 0.49527764, 0.49529161, 0.49530550, 0.49531930, 0.49533303, 0.49534667, 0.49536024, 0.49537372, 0.49538713, 0.49540046, 0.49541371, 0.49542689, 0.49543999, &
       0.49545302, 0.49546597, 0.49547885, 0.49549166, 0.49550439, 0.49551705, 0.49552964, 0.49554216, 0.49555462, 0.49556700, 0.49557931, 0.49559155, 0.49560373, 0.49561584, 0.49562788, 0.49563986, 0.49565177, 0.49566362, 0.49567540, 0.49568712, 0.49569877, 0.49571036, 0.49572189, 0.49573336, 0.49574477, 0.49575611, 0.49576740, 0.49577863, 0.49578979, 0.49580090, 0.49581195, 0.49582294, 0.49583387, 0.49584475, 0.49585557, 0.49586633, 0.49587704, 0.49588769, 0.49589829, 0.49590883, 0.49591932, 0.49592976, 0.49594014, 0.49595047, 0.49596075, 0.49597097, 0.49598114, 0.49599127, 0.49600134, 0.49601136, &
       0.49602133, 0.49603125, 0.49604112, 0.49605094, 0.49606072, 0.49607044, 0.49608012, 0.49608975, 0.49609933, 0.49610887, 0.49611836, 0.49612780, 0.49613720, 0.49614655, 0.49615586, 0.49616512, 0.49617434, 0.49618351, 0.49619264, 0.49620173, 0.49621077, 0.49621977, 0.49622873, 0.49623764, 0.49624651, 0.49625535, 0.49626414, 0.49627288, 0.49628159, 0.49629026, 0.49629888, 0.49630747, 0.49631602, 0.49632452, 0.49633299, 0.49634142, 0.49634981, 0.49635816, 0.49636648, 0.49637475, 0.49638299, 0.49639119, 0.49639936, 0.49640749, 0.49641558, 0.49642363, 0.49643165, 0.49643963, 0.49644758, 0.49645549, &
       0.49646336, 0.49647121, 0.49647901, 0.49648678, 0.49649452, 0.49650222, 0.49650989, 0.49651753, 0.49652513, 0.49653270, 0.49654024, 0.49654775, 0.49655522, 0.49656266, 0.49657006, 0.49657744, 0.49658478, 0.49659210, 0.49659938, 0.49660663, 0.49661385, 0.49662104, 0.49662819, 0.49663532, 0.49664242, 0.49664949, 0.49665653, 0.49666354, 0.49667052, 0.49667747, 0.49668439, 0.49669128, 0.49669814, 0.49670498, 0.49671179, 0.49671857, 0.49672532, 0.49673204, 0.49673874, 0.49674541, 0.49675205, 0.49675866, 0.49676525, 0.49677181, 0.49677835, 0.49678485, 0.49679133, 0.49679779, 0.49680422, 0.49681062,0.49681700 /)
  real*8,dimension(451),parameter :: ycoarse=(/0.496817007, 0.496879414, 0.496939422, 0.496997165, 0.497052770, 0.497106353, 0.497158022, 0.497207879, 0.497256017, 0.497302523, 0.497347479, 0.497390961, 0.497433040, 0.497473784, 0.497513254, 0.497551510, 0.497588607, 0.497624597, 0.497659528, 0.497693446, 0.497726396, 0.497758418, 0.497789550, 0.497819829, 0.497849290, 0.497877965, 0.497905886, 0.497933081, 0.497959579, 0.497985407, 0.498010589, 0.498035149, 0.498059110, 0.498082493, 0.498105320, 0.498127610, 0.498149381, 0.498170652, 0.498191440, 0.498211761, 0.498231629, 0.498251062, 0.498270071, 0.498288673, 0.498306878, 0.498324700, 0.498342150, 0.498359241, 0.498375984, 0.498392387, &
       0.498408463, 0.498424221, 0.498439669, 0.498454818, 0.498469675, 0.498484250, 0.498498549, 0.498512581, 0.498526353, 0.498539873, 0.498553146, 0.498566181, 0.498578983, 0.498591558, 0.498603912, 0.498616052, 0.498627983, 0.498639709, 0.498651237, 0.498662571, 0.498673716, 0.498684677, 0.498695458, 0.498706064, 0.498716499, 0.498726767, 0.498736872, 0.498746817, 0.498756608, 0.498766246, 0.498775737, 0.498785082, 0.498794286, 0.498803351, 0.498812282, 0.498821079, 0.498829748, 0.498838290, 0.498846708, 0.498855005, 0.498863183, 0.498871246, 0.498879195, 0.498887032, 0.498894761, 0.498902384, 0.498909901, 0.498917317, 0.498924632, 0.498931850,   &
       0.498938970, 0.498945997, 0.498952931, 0.498959775, 0.498966529, 0.498973197, 0.498979779, 0.498986277, 0.498992693, 0.498999028, 0.499005284, 0.499011463, 0.499017565, 0.499023592, 0.499029546, 0.499035427, 0.499041238, 0.499046979, 0.499052651, 0.499058257, 0.499063797, 0.499069271, 0.499074683, 0.499080031, 0.499085318, 0.499090545, 0.499095712, 0.499100821, 0.499105873, 0.499110868, 0.499115808, 0.499120693, 0.499125524, 0.499130303, 0.499135029, 0.499139705, 0.499144330, 0.499148906, 0.499153433, 0.499157912, 0.499162344, 0.499166729, 0.499171069, 0.499175364, 0.499179615, 0.499183822, 0.499187986, 0.499192108, 0.499196188, 0.499200228,   &
       0.499204226, 0.499208185, 0.499212105, 0.499215987, 0.499219830, 0.499223635, 0.499227404, 0.499231137, 0.499234833, 0.499238494, 0.499242120, 0.499245712, 0.499249270, 0.499252795, 0.499256286, 0.499259745, 0.499263172, 0.499266568, 0.499269932, 0.499273266, 0.499276569, 0.499279843, 0.499283087, 0.499286301, 0.499289488, 0.499292645, 0.499295775, 0.499298878, 0.499301953, 0.499305001, 0.499308023, 0.499311018, 0.499313988, 0.499316932, 0.499319851, 0.499322745, 0.499325615, 0.499328461, 0.499331282, 0.499334080, 0.499336855, 0.499339606, 0.499342335, 0.499345042, 0.499347726, 0.499350388, 0.499353029, 0.499355648, 0.499358247, 0.499360824,   &
       0.499363381, 0.499365917, 0.499368433, 0.499370929, 0.499373406, 0.499375863, 0.499378301, 0.499380720, 0.499383121, 0.499385502, 0.499387866, 0.499390211, 0.499392539, 0.499394848, 0.499397141, 0.499399416, 0.499401673, 0.499403914, 0.499406138, 0.499408346, 0.499410537, 0.499412713, 0.499414872, 0.499417015, 0.499419143, 0.499421255, 0.499423352, 0.499425434, 0.499427500, 0.499429552, 0.499431590, 0.499433612, 0.499435621, 0.499437615, 0.499439595, 0.499441562, 0.499443514, 0.499445453, 0.499447379, 0.499449291, 0.499451190, 0.499453076, 0.499454949, 0.499456809, 0.499458657, 0.499460492, 0.499462314, 0.499464125, 0.499465923, 0.499467709,   &
       0.499469484, 0.499471246, 0.499472997, 0.499474736, 0.499476464, 0.499478180, 0.499479886, 0.499481580, 0.499483263, 0.499484935, 0.499486597, 0.499488248, 0.499489888, 0.499491518, 0.499493137, 0.499494746, 0.499496345, 0.499497934, 0.499499513, 0.499501082, 0.499502641, 0.499504190, 0.499505730, 0.499507260, 0.499508781, 0.499510292, 0.499511795, 0.499513288, 0.499514771, 0.499516246, 0.499517712, 0.499519169, 0.499520618, 0.499522057, 0.499523488, 0.499524910, 0.499526324, 0.499527730, 0.499529127, 0.499530516, 0.499531897, 0.499533270, 0.499534635, 0.499535991, 0.499537340, 0.499538681, 0.499540014, 0.499541340, 0.499542658, 0.499543968,   &
       0.499545271, 0.499546567, 0.499547855, 0.499549136, 0.499550410, 0.499551676, 0.499552935, 0.499554188, 0.499555433, 0.499556671, 0.499557903, 0.499559127, 0.499560345, 0.499561556, 0.499562761, 0.499563959, 0.499565150, 0.499566335, 0.499567514, 0.499568686, 0.499569851, 0.499571011, 0.499572164, 0.499573311, 0.499574452, 0.499575587, 0.499576715, 0.499577838, 0.499578955, 0.499580066, 0.499581171, 0.499582270, 0.499583364, 0.499584452, 0.499585534, 0.499586610, 0.499587681, 0.499588747, 0.499589807, 0.499590861, 0.499591910, 0.499592954, 0.499593992, 0.499595025, 0.499596053, 0.499597076, 0.499598093, 0.499599106, 0.499600113, 0.499601115,   &
       0.499602112, 0.499603105, 0.499604092, 0.499605074, 0.499606052, 0.499607025, 0.499607992, 0.499608956, 0.499609914, 0.499610868, 0.499611817, 0.499612761, 0.499613701, 0.499614637, 0.499615567, 0.499616494, 0.499617416, 0.499618333, 0.499619246, 0.499620155, 0.499621059, 0.499621959, 0.499622855, 0.499623747, 0.499624634, 0.499625517, 0.499626397, 0.499627271, 0.499628142, 0.499629009, 0.499629872, 0.499630731, 0.499631585, 0.499632436, 0.499633283, 0.499634126, 0.499634965, 0.499635801, 0.499636632, 0.499637460, 0.499638284, 0.499639104, 0.499639921, 0.499640733, 0.499641543, 0.499642348, 0.499643150, 0.499643948, 0.499644743, 0.499645534,   &
       0.499646322, 0.499647106, 0.499647887, 0.499648664, 0.499649438, 0.499650209, 0.499650976, 0.499651739, 0.499652500, 0.499653257, 0.499654011, 0.499654761, 0.499655508, 0.499656252, 0.499656993, 0.499657731, 0.499658465, 0.499659197, 0.499659925, 0.499660650, 0.499661372, 0.499662091, 0.499662807, 0.499663520, 0.499664230, 0.499664937, 0.499665640, 0.499666341, 0.499667039, 0.499667735, 0.499668427, 0.499669116, 0.499669803, 0.499670486, 0.499671167, 0.499671845, 0.499672520, 0.499673193, 0.499673862, 0.499674529, 0.499675194, 0.499675855, 0.499676514, 0.499677170, 0.499677824, 0.499678474, 0.499679123, 0.499679768, 0.499680411, 0.499681052,0.499681690 /)

  !! precomputed Gaussian definite integrals relative to 0 in units of FWHM
  real*8 :: gaussian_integral_xstep=0.01 ,gaussian_integral_xmax=3   !grid step and maximum value 
  real*8,dimension(301),parameter :: gaussian_integral_y=(/ &
       0.000000000000000e+00, 9.393070630919931e-03, 1.878093480303895e-02, 2.815839471357681e-02, 3.752026984781386e-02, 4.686140556326247e-02, 5.617668160226773e-02, 6.546102050961244e-02, 7.470939593206832e-02, 8.391684077729195e-02, 9.307845521000496e-02, 1.021894144640239e-01, 1.112449764494106e-01, 1.202404891347974e-01, 1.291713976857947e-01, 1.380332513413170e-01, &
       1.468217100106479e-01, 1.555325505751166e-01, 1.641616728793590e-01, 1.727051053982901e-01, 1.811590105671093e-01, 1.895196897628955e-01, 1.977835879276126e-01, 2.059472978236414e-01, 2.140075639142656e-01, 2.219612858628657e-01, 2.298055216459126e-01, 2.375374902761891e-01, 2.451545741340020e-01, 2.526543209054733e-01, 2.600344451283097e-01, 2.672928293467356e-01, &
       2.744275248785428e-01, 2.814367521984388e-01, 2.883189009430738e-01, 2.950725295442796e-01, 3.016963644981676e-01, 3.081892992787896e-01, 3.145503929060773e-01, 3.207788681787253e-01, 3.268741095835760e-01, 3.328356608938945e-01, 3.386632224696857e-01, 3.443566482739077e-01, 3.499159426190612e-01, 3.553412566592002e-01, 3.606328846428969e-01, 3.657912599431135e-01, &
       3.708169508802839e-01, 3.757106563551822e-01, 3.804732013083661e-01, 3.851055320231170e-01, 3.896087112888705e-01, 3.939839134421315e-01, 3.982324193018064e-01, 4.023556110157579e-01, 4.063549668352036e-01, 4.102320558333314e-01, 4.139885325842079e-01, 4.176261318177014e-01, 4.211466630657398e-01, 4.245520053147751e-01, 4.278441016788367e-01, 4.310249541070231e-01, &
       4.340966181387192e-01, 4.370611977192256e-01, 4.399208400878621e-01, 4.426777307499575e-01, 4.453340885434627e-01, 4.478921608102393e-01, 4.503542186813708e-01, 4.527225524851302e-01, 4.549994672855205e-01, 4.571872785585784e-01, 4.592883080129117e-01, 4.613048795602199e-01, 4.632393154408320e-01, 4.650939325085939e-01, 4.668710386787422e-01, 4.685729295417234e-01, &
       4.702018851452549e-01, 4.717601669462810e-01, 4.732500149338539e-01, 4.746736449233695e-01, 4.760332460220130e-01, 4.773309782647171e-01, 4.785689704194145e-01, 4.797493179598694e-01, 4.808740812039073e-01, 4.819452836144258e-01, 4.829649102601608e-01, 4.839349064328088e-01, 4.848571764167590e-01, 4.857335824073743e-01, 4.865659435734758e-01, 4.873560352594337e-01, &
       4.881055883220396e-01, 4.888162885971462e-01, 4.894897764908882e-01, 4.901276466901678e-01, 4.907314479869703e-01, 4.913026832109984e-01, 4.918428092650481e-01, 4.923532372575204e-01, 4.928353327264460e-01, 4.932904159494145e-01, 4.937197623338279e-01, 4.941246028819484e-01, 4.945061247252806e-01, 4.948654717229091e-01, 4.952037451185183e-01, 4.955220042509300e-01, &
       4.958212673131253e-01, 4.961025121548551e-01, 4.963666771240919e-01, 4.966146619427343e-01, 4.968473286121406e-01, 4.970655023442417e-01, 4.972699725141602e-01, 4.974614936304448e-01, 4.976407863192157e-01, 4.978085383187028e-01, 4.979654054808501e-01, 4.981120127768479e-01, 4.982489553036425e-01, 4.983767992886646e-01, 4.984960830902008e-01, 4.986073181910175e-01, &
       4.987109901830274e-01, 4.988075597409641e-01, 4.988974635832045e-01, 4.989811154180454e-01, 4.990589068739034e-01, 4.991312084120650e-01, 4.991983702207644e-01, 4.992607230895127e-01, 4.993185792627418e-01, 4.993722332719571e-01, 4.994219627457229e-01, 4.994680291969213e-01, 4.995106787868399e-01, 4.995501430657504e-01, 4.995866396897412e-01, 4.996203731136576e-01, &
       4.996515352600947e-01, 4.996803061644651e-01, 4.997068545962411e-01, 4.997313386565380e-01, 4.997539063522684e-01, 4.997746961471544e-01, 4.997938374899370e-01, 4.998114513201666e-01, 4.998276505520014e-01, 4.998425405364766e-01, 4.998562195027373e-01, 4.998687789787587e-01, 4.998803041920972e-01, 4.998908744512373e-01, 4.999005635081140e-01, 4.999094399024038e-01, &
       4.999175672881835e-01, 4.999250047435667e-01, 4.999318070639265e-01, 4.999380250393163e-01, 4.999437057166987e-01, 4.999488926475877e-01, 4.999536261217055e-01, 4.999579433872452e-01, 4.999618788583255e-01, 4.999654643102083e-01, 4.999687290628441e-01, 4.999717001532919e-01, 4.999744024975515e-01, 4.999768590423290e-01, 4.999790909072415e-01, 4.999811175179530e-01, &
       4.999829567307169e-01, 4.999846249487824e-01, 4.999861372311100e-01, 4.999875073938192e-01, 4.999887481047806e-01, 4.999898709717433e-01, 4.999908866243756e-01, 4.999918047905772e-01, 4.999926343674094e-01, 4.999933834869698e-01, 4.999940595775244e-01, 4.999946694201962e-01, 4.999952192014907e-01, 4.999957145619290e-01, 4.999961606410412e-01, 4.999965621189614e-01, &
       4.999969232548529e-01, 4.999972479223773e-01, 4.999975396424113e-01, 4.999978016132018e-01, 4.999980367381404e-01, 4.999982476513249e-01, 4.999984367410680e-01, 4.999986061715024e-01, 4.999987579024206e-01, 4.999988937074822e-01, 4.999990151909098e-01, 4.999991238027887e-01, 4.999992208530760e-01, 4.999993075244204e-01, 4.999993848838842e-01, 4.999994538936537e-01, &
       4.999995154208200e-01, 4.999995702463020e-01, 4.999996190729840e-01, 4.999996625331295e-01, 4.999997011951324e-01, 4.999997355696595e-01, 4.999997661152358e-01, 4.999997932433199e-01, 4.999998173229125e-01, 4.999998386847375e-01, 4.999998576250344e-01, 4.999998744089938e-01, 4.999998892738690e-01, 4.999999024317915e-01, 4.999999140723171e-01, 4.999999243647268e-01, &
       4.999999334601047e-01, 4.999999414932134e-01, 4.999999485841850e-01, 4.999999548400454e-01, 4.999999603560876e-01, 4.999999652171065e-01, 4.999999694985109e-01, 4.999999732673222e-01, 4.999999765830720e-01, 4.999999794986075e-01, 4.999999820608138e-01, 4.999999843112624e-01, 4.999999862867908e-01, 4.999999880200227e-01, 4.999999895398327e-01, 4.999999908717618e-01, &
       4.999999920383892e-01, 4.999999930596635e-01, 4.999999939531991e-01, 4.999999947345399e-01, 4.999999954173947e-01, 4.999999960138466e-01, 4.999999965345396e-01, 4.999999969888443e-01, 4.999999973850056e-01, 4.999999977302732e-01, 4.999999980310186e-01, 4.999999982928377e-01, 4.999999985206425e-01, 4.999999987187421e-01, 4.999999988909145e-01, 4.999999990404702e-01, &
       4.999999991703080e-01, 4.999999992829651e-01, 4.999999993806609e-01, 4.999999994653351e-01, 4.999999995386828e-01, 4.999999996021839e-01, 4.999999996571298e-01, 4.999999997046466e-01, 4.999999997457161e-01, 4.999999997811935e-01, 4.999999998118231e-01, 4.999999998382527e-01, 4.999999998610457e-01, 4.999999998806914e-01, 4.999999998976151e-01, 4.999999999121858e-01, &
       4.999999999247238e-01, 4.999999999355066e-01, 4.999999999447748e-01, 4.999999999527368e-01, 4.999999999595728e-01, 4.999999999654389e-01, 4.999999999704698e-01, 4.999999999747821e-01, 4.999999999784763e-01, 4.999999999816393e-01, 4.999999999843460e-01, 4.999999999866609e-01, 4.999999999886397e-01, 4.999999999903302e-01, 4.999999999917736e-01, 4.999999999930053e-01, &
       4.999999999940559e-01, 4.999999999949514e-01, 4.999999999957143e-01, 4.999999999963639e-01, 4.999999999969167e-01, 4.999999999973869e-01, 4.999999999977865e-01, 4.999999999981261e-01, 4.999999999984144e-01, 4.999999999986591e-01, 4.999999999988667e-01, 4.999999999990426e-01, 4.999999999991916e-01  &
       /)

contains

  subroutine single_channel_numerov(U,T,F,chi,N)
    !! Iteratively computes the matrices used in the renormalised
    !! Numerov method for wave function calculation.
    integer :: N
    real*8,intent(inout),dimension(N) :: U,T,F,chi
    integer :: i
    U = (2.0d0+10.0d0*T)/(1.0d0-T)
    F = 0.0d0
    chi = 0.0d0
    F(1) = 0.
    F(2) = 1.0d-0
    do i=3,N
       F(i) = U(i-1)*F(i-1) - F(i-2)
       chi(i) = F(i)/(1-T(i))
    end do
  end subroutine single_channel_numerov

  subroutine single_channel_renormalised_numerov(U,T,F,chi,RR,N)
    !! Iteratively computes the matrices used in the renormalised
    !! Numerov method for wave function calculation.
    integer :: N
    real*8,intent(inout),dimension(0:N-1) :: U,T,F,chi,RR
    ! real*8,parameter :: MAXCHI=1e10
    real*8,parameter :: MAXCHI=1e20
    ! logical :: chi0_normalised=.false.
    integer :: i,j
    RR(0) = U(0)
    F(0) = 1.0d-0
    do i=1,N-1
       RR(i) = U(i)-RR(i-1)**(-1) 
       F(i) = RR(i-1)*F(i-1)
       chi(i) = (1.-T(i))**(-1)*F(i)
       !! if chi(i) is too big renormalise to 1.
       if (dabs(chi(i)).gt.MAXCHI) then
          do j=1,i
             chi(j) = chi(j)/dabs(chi(i))
             F(j) = F(j)/dabs(F(i))
          end do
       end if
    end do
  end subroutine single_channel_renormalised_numerov

  subroutine compute_single_channel_renormalised_numerov(mu,dR,V,E,chi,N)
    !! Iteratively computes the matrices used in the renormalised
    !! Numerov method for wave function calculation.
    integer :: N                           !grid length
    real*8,intent(in),dimension(N) :: V !potential energy
    real*8,intent(out),dimension(N) :: chi !wavefunction
    real*8,intent(in) :: mu,dR,E           !reduced mass, grid step, energy to compute at
    real*8,dimension(N) :: U,T,F,RR        !Numerov method matrices
    real*8,parameter :: MAXCHI=1e20 !before renormalisation occurs
    real*8,parameter :: constant0=0.029660161 ! assumes input units of a.m.u/cm-1/A 1e-20*constants.atomic_mass*constants.speed_of_light*100.*constants.h/constants.hbar**2
    integer :: i,j
    !! Compute Numerov matrics
    T = (-dR**2/12)*(2*mu)*(E-V)*constant0
    U = (1.0-T)**(-1)*(2.0+10.0*T)
    chi = 0.0
    !! iterate solution
    RR(1) = U(1)
    F(1) = 1.0d0
    do i=1+1,N
       RR(i) = U(i)-RR(i-1)**(-1) 
       F(i) = RR(i-1)*F(i-1)
       chi(i) = (1.-T(i))**(-1)*F(i)
       !! if chi(i) is too big renormalise to 1.
       if (abs(chi(i)).gt.MAXCHI) then
          do j=1,i
             chi(j) = chi(j)/abs(chi(i))
             F(j) = F(j)/abs(F(i))
          end do
       end if
    end do
  end subroutine compute_single_channel_renormalised_numerov

  subroutine calculate_single_channel_wavefunction(type,chi,V,dR,mu,E,ibeg,iend,N)
    !! Compute the wavefunction for a single channel bound state.
    integer,intent(inout) :: N
    real*8,intent(in),dimension(N) :: V      !potential energy curve
    real*8,intent(inout),dimension(N) :: chi !computed wavefunction
    real*8,intent(in) :: dR,mu,E !grid step (A), reduced mass (amu), energy (cm-1)
    integer,intent(inout) :: ibeg,iend             !indices of begin and end point of calculation
    integer :: iinner,iouter,ijoin             !indices of inner and outer classical turning points and join point if bound
    real*8,parameter :: phi0=1.0d4 !sufficiently large phase to go beyond classical turnings points to begin and end calculations
    !! what type of calculation 'outwards' to go from inside inner
    !! turning point to outside of domain (if unbound energy) or
    !! beyond outer turning pointt if bount. If 'auto' then bound
    !! state are a joined combination of inwards and outwards
    !! solutions.
    character(len=*),intent(in):: type  
    !! work variables
    real*8 :: x
    real*8,dimension(N) :: xarr,yarr
    integer :: i
    !! find inner classical turning point
    do iinner=1,N-2
       if ((V(iinner).gt.E).and.(V(iinner+1).lt.E)) exit
    end do
    !! find point inside turning point where approximate accumulated
    !! phase is greater than phi0
    x = 0.0d0
    do ibeg = iinner,2,-1
       x = x+(V(ibeg)-E)*dR/mu
       if (x.gt.phi0) exit
    end do
    !! Unbound energy
    if (V(N).lt.E) then
       iend = N
       chi = 0.0
       call compute_single_channel_renormalised_numerov(mu,dR,V(ibeg:iend),E,chi(ibeg:iend),iend-ibeg+1)
       !! ADD NORMALISATION HERE
       !! bound problem, find outer classical turning point
    else
       do iouter=N,2,-1
          if ((V(iouter).gt.E).and.(V(iouter-1).lt.E)) exit
       end do
       !! find point inside turning point where approximate accumulated
       !! phase is greater than phi0
       x = 0.0d0
       do iend = iouter,N-1
          x = x+(V(iend)-E)*dR/mu
          if (x.gt.phi0) exit
       end do
       !! 'auto' or 'join' then compute inner and outer solutions and
       !! match at classically allowed joint point
       if (type(1:4).eq.'auto') then
          !! compute outwards solution to join point
          ijoin = int((iinner+iouter)/2)
          chi = 0.0
          call compute_single_channel_renormalised_numerov(mu,dR,V(ibeg:ijoin),E,chi(ibeg:ijoin),ijoin-ibeg+1+1)
          !! compute inwards solution to join point
          do i=iend,ijoin,-1
             xarr(iend-i+1) = V(i)
          end do
          call compute_single_channel_renormalised_numerov(mu,dR,xarr,E,yarr,iend-ijoin+1)
          !! Compute the factor needed to rescale inwards solution to
          !! match outwards at join point. The two cases are to avoid
          !! a comparison at a node where the wavefunction is zero.
          if (abs(chi(ijoin)).gt.abs(chi(ijoin+1))) then
             x = chi(ijoin)/yarr(iend-ijoin+1)
          else
             x = chi(ijoin+1)/yarr(iend-ijoin+1-1)
          end if
          !! rescale inwards solution
          do i=iend,ijoin,-1
             chi(i) = yarr(iend-i+1)*x
          end do
          iend = iend -1              !return one less so not zero chi -- a bug in indexing?
          !! normalise and set phase
          x = 0.0
          do i=ibeg,iend
             x = x + chi(i)**2
          enddo
          x = x*dR
          x = abs(x)
          if (chi(iinner).lt.0.0) x = -x
          do i=ibeg,iend
             chi(i) = chi(i)/sqrt(x)
          enddo
          !! compute bound state beyond outer turning point -- to get
          !! asymptotic sign probably
       elseif (type(1:8).eq.'outwards') then
          call compute_single_channel_renormalised_numerov(mu,dR,V(ibeg:iend),E,chi(ibeg:iend),iend-ibeg+1)
       else
          write(*,*) "Bad type:",type
          stop 1
       end if
    end if
  end subroutine calculate_single_channel_wavefunction

  subroutine find_single_channel_bound_levels(nodes,E,chi,nfound,V,dR,mu,Emin,Emax,Estep,Etol,N)
    !! Find all bound states between Emin and Emax. 
    integer,parameter :: MAXSOLUTIONS=1000 !must be this size in calling function -- yuck
    integer :: N
    real*8,intent(in),dimension(N) :: V
    integer,intent(inout) :: nfound                       !how many levels found
    real*8,intent(inout),dimension(MAXSOLUTIONS,N) :: chi !level wavefunctions
    real*8,intent(inout),dimension(MAXSOLUTIONS) :: E      !found level energies
    integer*8,intent(inout),dimension(MAXSOLUTIONS) :: nodes !leve node count
    real*8,intent(in) :: dR,mu,Emin,Emax,Etol,Estep
    real*8,parameter :: MAXCHI=1e20
    real*8 :: x
    real*8 :: Escan_beg,Escan_end,Escan,Escan_prev
    real*8 :: Ezoom_beg,Ezoom_end,Ezoom_mid
    real*8,dimension(N) :: xarr
    logical :: scan_outer_sign,scan_outer_sign_prev
    logical :: zoom_outer_sign_beg,zoom_outer_sign_end,zoom_outer_sign_mid
    integer :: i,j,ibeg,iend
    !! find equilibrium energy
    x = V(1)
    do i=1,N
       if (V(i).lt.x) x = V(i)
    end do
    !! coarse search
    Escan_beg = max(Emin,x+Etol) 
    Escan_end = min(Emax,V(N)-Etol)
    Escan = Escan_beg
    nfound = 0
    do while (Escan.le.Escan_end)
       call calculate_single_channel_wavefunction('outwards',xarr,V,dR,mu,Escan,ibeg,iend,N)
       scan_outer_sign = (xarr(iend).ge.0) !get sign of endpoint of wavefunction -- T is positive, F is negative
       !! a change in sign indicates a bound level between this and
       !! the previous energy (not the first energy). Zoom in on it by
       !! bisection.
       if ((Escan.gt.Escan_beg).and.(scan_outer_sign.neqv.scan_outer_sign_prev)) then
          Ezoom_beg = Escan_prev
          Ezoom_end = Escan
          zoom_outer_sign_beg = scan_outer_sign_prev
          zoom_outer_sign_end = scan_outer_sign
          do while ((Ezoom_end-Ezoom_beg).gt.Etol)
             Ezoom_mid = (Ezoom_beg+Ezoom_end)/2.0
             call calculate_single_channel_wavefunction('outwards',xarr,V,dR,mu,Ezoom_mid,ibeg,iend,N)
             zoom_outer_sign_mid = (xarr(iend).ge.0)
             if (zoom_outer_sign_mid.neqv.zoom_outer_sign_beg) then
                Ezoom_end = Ezoom_mid
             else
                Ezoom_beg = Ezoom_mid
                zoom_outer_sign_beg = zoom_outer_sign_mid
                zoom_outer_sign_mid = zoom_outer_sign_end
             end if
          end do
          !! get final normalised wavefunction
          call calculate_single_channel_wavefunction('auto',xarr,V,dR,mu,Ezoom_mid,ibeg,iend,N)
          nfound = nfound + 1
          if (nfound.gt.MAXSOLUTIONS) then
             write (*,*)  "Increase MAXSOLUTIONS"
             stop 1
          end if
          chi(nfound,:) = xarr
          E(nfound) = (Ezoom_beg+Ezoom_end)/2.0
          !! get node count
          nodes(nfound) = 0
          do j=ibeg,iend-1
             if (E(nfound).lt.V(j)) cycle !nodes only in classically allowed reign -- else numerical noise
             if ((chi(nfound,j)*chi(nfound,j+1)).lt.0.0) nodes(nfound) = nodes(nfound)+1
          end do
       end if
       !! advance loop
       scan_outer_sign_prev = scan_outer_sign
       Escan_prev = Escan
       Escan = Escan + Estep
    end do
  end subroutine find_single_channel_bound_levels

  ! subroutine calculate_multi_channel_wavefunction_multiple_energies(V,E,dR,mu,chi,nR,nV,nE)
  ! !! Solve the coupled Schrodinger equation outwards using the
  ! !! Johnson renormalised method for multiple energies, E. No
  ! !! normalisation.  This might require a lot of memory!
  ! integer :: nR                ! number of grid points
  ! integer :: nV               ! number of coupled states
  ! integer :: nE               ! number of energies
  ! real*8,intent(in),dimension(nE) :: E                 ! energy (cm-1)
  ! real*8,intent(in) :: dR                ! grid step (Angstroms)
  ! real*8,intent(in) :: mu                ! reduced mass (amu)
  ! real*8,intent(inout),dimension(nR,nV,nV) :: V !potential matrix (cm-1)
  ! real*8,intent(inout),dimension(nR,nV,nV,nE) :: chi !coupled wavefunction
  ! integer :: i
  ! do i=1,nE
  ! call calculate_multi_channel_wavefunction(V,E(i),dR,mu,chi(:,:,:,i),nR,nV)
  ! end do
  ! end subroutine calculate_multi_channel_wavefunction_multiple_energies

  subroutine calculate_multi_channel_wavefunction(V,E,dR,mu,chi,nR,nV)
    !! Solve the coupled Schrodinger equation outwards using the
    !! Johnson renormalised method. No normalisation.
    integer :: nR                ! number of grid points
    integer :: nV               ! number of coupled states
    real*8 :: E                 ! energy (cm-1)
    real*8 :: dR                ! grid step (Angstroms)
    real*8 :: mu                ! reduced mass (amu)
    real*8 :: constant0 = 0.029660161 ! assumes input units of a.m.u/cm-1/A 1e-20*constants.atomic_mass*constants.speed_of_light*100.*constants.h/constants.hbar**2
    real*8,intent(inout),dimension(nR,nV,nV) :: V !potential matrix (cm-1)
    real*8,intent(inout),dimension(nR,nV,nV) :: chi !coupled wavefunction
    real*8,dimension(nR,nV,nV) :: U,F,RR,ITinv,RRinv,T,I1,tmp
    integer :: i
    !! identity matrix
    I1 = 0.
    do i=1,nV
       I1(:,i,i) = 1.
    end do
    !! various potential matrices
    T = -dR**2./12.*2.*mu*(E*I1-V)*constant0
    tmp = I1-T
    do i=1,nR
       call invert_matrix(tmp(i,:,:),ITinv(i,:,:),nV)
    end do
    U = 12*ITinv - 10*I1
    !! calc ratio outwards
    RR = 0.
    RRinv = 0.
    RR(1,:,:) = U(1,:,:)
    call invert_matrix(RR(1,:,:),RRinv(1,:,:),nV)
    do i=2,nR
       RR(i,:,:) = U(i,:,:)-RRinv(i-1,:,:)
       call invert_matrix(RR(i,:,:),RRinv(i,:,:),nV)
    end do
    !! calculate F and chi inwards
    F = 0.
    do i=1,nV
       if (V(nR,i,i).lt.E) then
          F(nR,i,i) = 1         !unbound diagonal outer value is 1, closed chanVels is 0
       end if
    end do
    chi = 0.                    !initialise wavefunction
    call matrix_multiply(ITinv(nR,:,:),F(nR,:,:),chi(nR,:,:),nV,nV,nV)
    do i=nR-1,1,-1
       call matrix_multiply(RRinv(i+1,:,:),F(i+1,:,:),F(i,:,:),nV,nV,nV) !get F 
       call matrix_multiply(ITinv(i,:,:),F(i,:,:),chi(i,:,:),nV,nV,nV)
    end do
  end subroutine calculate_multi_channel_wavefunction

  function gaussian_definite_integral(a,b) result(x)
    !! Use precomputed values of the indefinite integral of a unit
    !! area Gaussian. Linear interpolation between a and b in units
    !! of FWHM. Absolute accuracy is better than 1e-4. Precomputed
    !! values are among module variables.
    real*8,intent(in) :: a,b    !integral limits in units of FWHM
    real*8 :: p,q,ya,yb
    real*8 :: x      !the indefinite integral between these limits
    integer :: i
    !! get absolute integral 0..|a|
    if (abs(a).gt.(gaussian_integral_xmax-gaussian_integral_xstep)) then
       ya = 0.5
    else
       p = abs(a)/gaussian_integral_xstep
       i = ceiling(p)             !lower point bounding y
       q = mod(p,1.)                  !distance of y from lower point
       !! interpolate or use end points if near (avoid division by zero)
       ya = gaussian_integral_y(i)*(1.-q) + gaussian_integral_y(i+1)*q  !linear interpolation between bounding points
    end if
    !! get absolute integral 0..|b|
    if (abs(b).gt.(gaussian_integral_xmax-gaussian_integral_xstep)) then
       yb = 0.5
    else
       p = abs(b)/gaussian_integral_xstep
       i = ceiling(p)             !lower point bounding y
       q = mod(p,1.)                  !distance of y from lower point
       !! interpolate or use end points if near (avoid division by zero)
       yb = gaussian_integral_y(i)*(1.-q) + gaussian_integral_y(i+1)*q  !linear interpolation between bounding points
    end if
    !! get a..b
    if (b.lt.0.0) yb = -yb
    if (a.lt.0.0) ya = -ya
    x = yb-ya
  end function gaussian_definite_integral
  
  subroutine stepwise_gaussian(center,area,fwhm,x,y,nx)
    !! Compute a Gaussian on grid with the correct (trapezium) rule
    !! integral. Note adds to y!
    real*8,intent(in) :: center !center frequency of lines
    real*8,intent(in) :: area !integrated strength of lines
    real*8,intent(in) :: fwhm !full-width half-maximum of lines
    integer*8 :: nx           !length of input/output x/y arrays
    real*8,intent(in),dimension(nx) :: x !input frequency -- must be monotonically increasing and even grid -- NOT CHECKED
    real*8,intent(inout),dimension(nx) :: y !output spectrum
    real*8,dimension(nx+1) :: xmid,xfwhm !midpoints of x -- and outer points, and interms of fwhm from cetner
    real*8,parameter :: maxcoarse=400     !the maximum number of linewidths treatable by the definite integral subroutine -- this must be manually made consistent with that routine
    integer*8 :: i
    !! compute midpoints between input points
    xmid(2:nx-1) = 0.5*(x(1:nx-1)+x(2:nx))       
    xmid(1) = x(1)-0.5*(x(2)-x(1))
    xmid(nx+1) = x(nx)+0.5*(x(nx)-x(nx-1))
    !! handle fwhm=0
    if (fwhm.eq.0.0) then
       !! check if outside
       if ((center.lt.xmid(1)).or.(center.gt.xmid(nx+1))) then
          !! do nothing outside range
          return
       else
          !! centroid
          do i=1,nx
             if (xmid(i+1).lt.center) cycle
             y(i)   = area*(xmid(i+1)-center )/(xmid(i+1)-xmid(i))
             y(i+1) = area/(center   -xmid(i))/(xmid(i+1)-xmid(i))
             exit
          end do
          return
       end if
    end if
    !! full calc
    xfwhm = (xmid-center)/fwhm
    do i=1,nx
       !! If the bounding points are both outside the region with
       !! precalculated definite integral then do set
       !! zero. Alternatively, could compute gaussian at point.
       if ((xfwhm(i+1).lt.-maxcoarse).or.(xfwhm(i).gt.maxcoarse)) then
          !! pass 
       else
          y(i) = y(i) + area/(xmid(i+1)-xmid(i))*gaussian_definite_integral(xfwhm(i),xfwhm(i+1))
       end if
    end do
  end subroutine stepwise_gaussian

  subroutine calculate_stepwise_gaussian_spectrum(x0,yint,xwid,x,y,nfwhm,nx,nlines)
    !! Compute sum of all Gaussians on given domain. The line centers
    !! are computed to have integrated values consisted with a
    !! stepwise function on the input regular grid.  This is useful
    !! where the line center is unresolved. Optionally limit to a
    !! maximum number of full-width half-maximums to include.
    integer*8 :: nlines           !number of lines
    real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
    real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
    real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
    integer*8,intent(in) :: nfwhm                               !number of fwhms to include,  requires even grid
    integer*8 :: nx                               !length of output frequency array
    real*8,intent(in),dimension(nx) :: x        !input frequency -- must be monotonically increasing and even grid -- NOT CHECKED
    real*8,intent(inout),dimension(nx) :: y     !output spectrum
    real*8 :: xstep
    integer*8 :: i,ibeg,iend
    y = 0.                    !output spectrum
    xstep = (x(nx)-x(1))/(nx-1) !requires even grid
    !! loop over all lines
    !$OMP PARALLEL
    !$OMP DO 
    do i=1,nlines
       !! if finite number of nfhwms (nfwhm>0) then determine indices
       !! of beginning and ending x
       if (nfwhm.le.0) then
          ibeg = 1
          iend = nx
       else
          ibeg = max(1 ,int((x0(i)-nfwhm*xwid(i)-x(1))/xstep))
          iend = min(nx,int((x0(i)+nfwhm*xwid(i)-x(1))/xstep))
          !! line is completely out of x range -- move on
          if ((ibeg.gt.nx).or.(iend.lt.1)) cycle
          !! ensure a reasonable number of points are actually included
          if ((iend-ibeg).lt.20) then
             ibeg = max(1,ibeg-10)
             iend = min(ibeg+20,nx)
          end if
       endif
       call stepwise_gaussian(x0(i),yint(i),xwid(i),x(ibeg:iend),y(ibeg:iend),iend-ibeg)
    end do
    !$OMP END DO
    !$OMP END PARALLEL
  end subroutine calculate_stepwise_gaussian_spectrum

  subroutine calculate_gaussian_spectrum(x0,yint,xwid,x,y,nfwhm,nx,nlines)
    !! Compute sum of all Gaussian on given domain, on any grid.
    integer*8 :: nlines           !number of lines
    real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
    real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
    real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
    integer*8,intent(in) :: nfwhm                               !number of fwhms to include,  requires even grid
    integer*8 :: nx                               !length of output frequency array
    real*8,intent(in),dimension(nx) :: x        !input frequency
    real*8,intent(inout),dimension(nx) :: y     !output spectrum
    real*8 :: xstep
    integer*8 :: i,j
    y = 0.
    !! if not nfwhm then calculate everywhere
    if (nfwhm.le.0) then
       !$OMP PARALLEL IF ((nx*nlines).gt.1000000)
       !$OMP DO 
       do j=1,nlines
          do i=1,nx
             y(i) = y(i) + yint(j)/xwid(j)*0.9394372786996513*exp(-((x(i)-x0(j))/xwid(j))**2*2.772588722239781)
          end do
       end do
       !$OMP END DO
       !$OMP END PARALLEL   
       !! else only add contribution for each line over nlines
    else
       xstep = x(2)-x(1)
       !! could rearrange to make parallel
       do j=1,nlines
          do i=max(1,int((x0(j)-nfwhm*xwid(j)-x(1))/xstep)),min(nx,int((x0(j)+nfwhm*xwid(j)-x(1))/xstep))
             y(i) = y(i) + yint(j)/xwid(j)*0.9394372786996513*exp(-((x(i)-x0(j))/xwid(j))**2*2.772588722239781)
          end do
       end do
    end if
  end subroutine calculate_gaussian_spectrum

  function lorentzian_definite_integral(a,b) result(x)
    !! Use precomputed values of the indefinite integral of a unit
    !! area Lorentzian. Linear interpolation between a and b in units
    !! of FWHM. Absolute accuracy is better than 1e-4. Precomputed
    !! values are among module variables.
    real*8,intent(in) :: a,b    !integral limits in units of FWHM
    real*8 :: aabs,babs
    real*8 :: x      !the indefinite integral between these limits
    real*8 :: ya,yb      !the indefinite integral between these limits
    real*8 :: xb1,xb2,yb1,yb2,xa1,xa2,ya1,ya2
    integer :: i
    !! interpolate definite integral between 0 and b
    babs = abs(b)
    aabs = abs(a)
    !! get nearest hashed definite integral values surrounding b
    if (babs.gt.(maxcoarse-2*dcoarse)) then
       !! if outside maxcoarse then neglect all remaining integral
       yb = 0.5
    else
       if (babs.ge.mincoarse) then
          i = floor((babs-mincoarse)/dcoarse)+1 
          xb1 = (i-1)*dcoarse+mincoarse
          yb1 = ycoarse(i)
          xb2 = xb1 + dcoarse
          yb2 = ycoarse(i+1)
       else if (babs.ge.minmedium) then
          i = floor((babs-minmedium)/dmedium)+1 
          xb1 = (i-1)*dmedium+minmedium
          yb1 = ymedium(i)
          xb2 = xb1 + dmedium
          yb2 = ymedium(i+1)
       else if (babs.ge.minfine) then
          i = floor((babs-minfine)/dfine)+1 
          xb1 = (i-1)*dfine+minfine
          yb1 = yfine(i)
          xb2 = xb1 + dfine
          yb2 = yfine(i+1)
       else
          write (*,*)  "Error: should not be able to get here."
          stop 1
       end if
       !! interpolate points around a and b and compute integral between the interpolated points
       yb = (yb1*(xb2-babs)+yb2*(babs-xb1))/(xb2-xb1)
    end if
    !! get nearest hashed definite integral values surrounding a
    if (aabs.gt.(maxcoarse-2*dcoarse)) then
       !! if outside maxcoarse then neglect all remaining integral
       ya = 0.5
    else
       if (aabs.ge.mincoarse) then
          i = floor((aabs-mincoarse)/dcoarse)+1 
          xa1 = (i-1)*dcoarse+mincoarse
          ya1 = ycoarse(i)
          xa2 = xa1 + dcoarse
          ya2 = ycoarse(i+1)
       else if (aabs.ge.minmedium) then
          i = floor((aabs-minmedium)/dmedium)+1 
          xa1 = (i-1)*dmedium+minmedium
          ya1 = ymedium(i)
          xa2 = xa1 + dmedium
          ya2 = ymedium(i+1)
       else if (aabs.ge.minfine) then
          i = floor((aabs-minfine)/dfine)+1 
          xa1 = (i-1)*dfine+minfine
          ya1 = yfine(i)
          xa2 = xa1 + dfine
          ya2 = yfine(i+1)
       else
          write (*,*)  "Error: should not be able to get here."
          stop 1
       end if
       !! interpolate points around a and b and compute integral between the interpolated points
       ya = (ya1*(xa2-aabs)+ya2*(aabs-xa1))/(xa2-xa1)
    end if
    !! compute definite integral difference
    if (b.lt.0.0) yb = -yb
    if (a.lt.0.0) ya = -ya
    x = yb-ya
  end function lorentzian_definite_integral

  function lorentzian(x,center,fwhm,area) result(y)
    !! Compute Lorentzian at a single point.
    real*8,intent(in) :: x,center,fwhm,area
    real*8 :: y     
    y = area*fwhm/6.283185307179586/((x-center)**2+fwhm**2/4.)
  end function lorentzian

  subroutine lorentzian_line(x,center,fwhm,area,y,n)
    !! Compute Lorentzian at a single point.
    integer*8 :: n
    real*8,intent(in),dimension(n) :: x
    real*8,intent(in) :: center,fwhm,area
    real*8,dimension(n),intent(inout) :: y     
    y = area*fwhm/6.283185307179586/((x-center)**2+fwhm**2/4.)
  end subroutine lorentzian_line

  subroutine add_lorentzian_line(x,center,fwhm,area,y,n)
    !! Compute Lorentzian at a single point.
    integer*8 :: n
    real*8,intent(in),dimension(n) :: x
    real*8,intent(in) :: center,fwhm,area
    real*8,dimension(n),intent(inout) :: y     
    y = y + area*fwhm/6.283185307179586/((x-center)**2+fwhm**2/4.)
  end subroutine add_lorentzian_line
  
  function normal_lorentzian(x) result(y)
    !! Compute Lorentzian at a single point with unit area and fwhm
    !! centered at x=0.
    real*8,intent(in) :: x
    real*8 :: y     
    y = 0.1591549430918953/(x**2+0.25)
  end function normal_lorentzian

  subroutine stepwise_lorentzian(center,area,fwhm,x,y,nx)
    !! Compute a Lorentzian on grid with the correct (trapezium) rule
    !! integral. Note adds to y!
    real*8,intent(in) :: center !center frequency of lines
    real*8,intent(in) :: area !integrated strength of lines
    real*8,intent(in) :: fwhm !full-width half-maximum of lines
    integer*8 :: nx           !length of input/output x/y arrays
    real*8,intent(in),dimension(nx) :: x !input frequency -- must be monotonically increasing and even grid -- NOT CHECKED
    real*8,intent(inout),dimension(nx) :: y !output spectrum
    real*8,dimension(nx+1) :: xmid,xfwhm !midpoints of x -- and outer points, and interms of fwhm from cetner
    real*8,parameter :: maxcoarse=400     !the maximum number of linewidths treatable by the definite integral subroutine -- this must be manually made consistent with that routine
    integer*8 :: i
    xmid(2:nx-1) = 0.5*(x(1:nx-1)+x(2:nx))       
    xmid(1) = x(1)-0.5*(x(2)-x(1))
    xmid(nx+1) = x(nx)+0.5*(x(nx)-x(nx-1))
    !! shortcut to put all are in one point if fwhm=0
    if (fwhm.eq.0.0) then
       do i=1,nx
          if (xmid(i+1).lt.center) cycle
          y(i) = area/(xmid(i+1)-xmid(i))
          exit
       end do
       return
    end if
    !! full calc
    xfwhm = (xmid-center)/fwhm
    do i=1,nx
       if ((xfwhm(i+1).lt.-maxcoarse).or.(xfwhm(i).gt.maxcoarse)) then
          y(i) = y(i) + area*fwhm/6.283185307179586/((x(i)-center)**2+fwhm**2/4.)
       else
          y(i) = y(i) + area/(xmid(i+1)-xmid(i))*lorentzian_definite_integral(xfwhm(i),xfwhm(i+1))
       end if
    end do
  end subroutine stepwise_lorentzian

  ! subroutine calculate_stepwise_lorentzian_spectrum(x0,yint,xwid,x,y,nfwhm,nx,nlines)
  ! !! Compute sum of all Lorentzian on given domain. The line centers
  ! !! are computed to have integrated values consisted with a
  ! !! stepwise function on the input regular grid.  This is useful
  ! !! where the line center is unresolved. Optionally limit to a
  ! !! maximum number of full-width half-maximums to include.
  ! integer*8 :: nlines           !number of lines
  ! real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
  ! real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
  ! real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
  ! integer*8,intent(in) :: nfwhm                               !number of fwhms to include,  requires even grid
  ! integer*8 :: nx                               !length of output frequency array
  ! real*8,intent(in),dimension(nx) :: x        !input frequency -- must be monotonically increasing and even grid -- NOT CHECKED
  ! real*8,intent(inout),dimension(nx) :: y     !output spectrum
  ! real*8 :: xstep
  ! integer*8 :: i,ibeg,iend
  ! y = 0.                    !output spectrum
  ! xstep = (x(nx)-x(1))/(nx-1)
  ! !! loop over all lines
  ! do i=1,nlines
  ! !! if finite number of nfhwms (nfwhm>0) then determine indices
  ! !! of beginning and ending x
  ! if (nfwhm.le.0) then
  ! ibeg = 1
  ! iend = nx
  ! else
  ! ibeg = max(1 ,int((x0(i)-nfwhm*xwid(i)-x(1))/xstep))
  ! iend = min(nx,int((x0(i)+nfwhm*xwid(i)-x(1))/xstep))
  ! !! line is completely out of x range -- move on
  ! if ((ibeg.gt.nx).or.(iend.lt.1)) cycle
  ! !! ensure a reasonable number of points are actually included
  ! if ((iend-ibeg).lt.20) then
  ! ibeg = max(1,ibeg-10)
  ! iend = min(ibeg+20,nx)
  ! end if
  ! endif
  ! call stepwise_lorentzian(x0(i),yint(i),xwid(i),x(ibeg:iend),y(ibeg:iend),iend-ibeg)
  ! end do
  ! end subroutine calculate_stepwise_lorentzian_spectrum

  subroutine calculate_stepwise_lorentzian_spectrum(x0,yint,xwid,x,y,nfwhm,nx,nlines)
    !! Compute sum of all Lorentzian on given domain. The line centers
    !! are computed to have integrated values consisted with a
    !! stepwise function on the input regular grid.  This is useful
    !! where the line center is unresolved. Optionally limit to a
    !! maximum number of full-width half-maximums to include.
    integer*8 :: nlines           !number of lines
    real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
    real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
    real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
    integer*8,intent(in) :: nfwhm                               !number of fwhms to include,  requires even grid
    integer*8 :: nx                               !length of output frequency array
    real*8,intent(in),dimension(nx) :: x        !input frequency -- must be monotonically increasing and even grid -- NOT CHECKED
    real*8,intent(inout),dimension(nx) :: y     !output spectrum
    real*8 :: xstep
    integer*8 :: i,ibeg,iend
    y = 0.                    !output spectrum
    xstep = (x(nx)-x(1))/(nx-1)
    !! loop over all lines
    !$OMP PARALLEL
    !$OMP DO 
    do i=1,nlines
       !! if finite number of nfhwms (nfwhm>0) then determine indices
       !! of beginning and ending x
       if (nfwhm.le.0) then
          ibeg = 1
          iend = nx
       else
          ibeg = max(1 ,int((x0(i)-nfwhm*xwid(i)-x(1))/xstep))
          iend = min(nx,int((x0(i)+nfwhm*xwid(i)-x(1))/xstep))
          !! line is completely out of x range -- move on
          if ((ibeg.gt.nx).or.(iend.lt.1)) cycle
          !! ensure a reasonable number of points are actually included
          if ((iend-ibeg).lt.20) then
             ibeg = max(1,ibeg-10)
             iend = min(ibeg+20,nx)
          end if
       endif
       call stepwise_lorentzian(x0(i),yint(i),xwid(i),x(ibeg:iend),y(ibeg:iend),iend-ibeg)
    end do
    !$OMP END DO
    !$OMP END PARALLEL   
  end subroutine calculate_stepwise_lorentzian_spectrum

  subroutine calculate_lorentzian_spectrum(x0,yint,xwid,x,y,nfwhm,nx,nlines)
    !! Compute sum of all Lorentzian on given domain, on any
    !! grid. Optionally limit to a maximum number of full-width
    !! half-maximums to include (not renormalised)
    integer*8 :: nlines           !number of lines
    real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
    real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
    real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
    integer*8,intent(in) :: nfwhm                               !number of fwhms to include,  requires even grid
    integer*8 :: nx                               !length of output frequency array
    real*8,intent(in),dimension(nx) :: x        !input frequency
    real*8,intent(inout),dimension(nx) :: y     !output spectrum
    real*8 :: xstep
    integer*8 :: i,j
    y = 0.
    !! if not nfwhm then calculate everywhere
    if (nfwhm.le.0) then
       !! OMP on 4 cores (8 threads) leads to a two times speedup on
       !! multi-second problem.  Reversing order of these loops
       !! resultsin a 2times speedup but slightly incorrect results!
       !$OMP PARALLEL IF ((nx*nlines).gt.1000000)
       !$OMP DO 
       do i=1,nx
          do j=1,nlines
             y(i) = y(i) + yint(j)*xwid(j)/6.283185307179586/((x(i)-x0(j))**2+xwid(j)**2/4.)
          end do
       end do
       !$OMP END DO
       !$OMP END PARALLEL   
       !! else only add contribution for each line over nlines
    else
       xstep = x(2)-x(1)
       !! could rearrange to make parallel
       do i=1,nlines
          do j=max(1,int((x0(i)-nfwhm*xwid(i)-x(1))/xstep)),min(nx,int((x0(i)+nfwhm*xwid(i)-x(1))/xstep))
             y(j) = y(j) + yint(i)*xwid(i)/6.283185307179586/((x(j)-x0(i))**2+xwid(i)**2/4.)
          end do
       end do
    end if
  end subroutine calculate_lorentzian_spectrum

  subroutine calculate_lorentzian_spectrum_approximate_wings(x0,yint,xwid,x,y,nfwhminner,nmerge,nx,nlines)
    !! Compute sum of all Lorentzian on given domain with linewing
    !! approximation, on regular monotonic grid.
    integer :: nlines           !number of lines
    real*8,intent(in),dimension(nlines) :: x0 !center frequency of lines
    real*8,intent(in),dimension(nlines) :: yint !integrated strength of lines
    real*8,intent(in),dimension(nlines) :: xwid !full-width half-maximum of lines
    integer :: nx                               !length of output frequency array
    real*8,intent(in),dimension(nx) :: x        !input frequency
    real*8,intent(inout),dimension(nx) :: y     !output spectrum
    real*8 :: xstep     !regular grid stepoutput spectrum
    real*8,dimension(nlines) :: tx0,tyint
    integer,dimension(nlines) :: innerbeg,innerend,ilines,tlines
    integer :: i,j,k,l,jprev,kprev,kbeg
    logical,dimension(nlines) :: linemask
    real*8,intent(in) :: nfwhminner        !how many FWHMs to explicitly compute line center over
    real*8,intent(in) :: nmerge        !how many FWHMs from current point before wing lines are merged
    !! get range of inner calculation for each line
    xstep = (x(nx)-x(1))/size(x)
    do i=1,nlines
       innerbeg(i) = max(1,int((x0(i)-nfwhminner*xwid(i)-x(1))/xstep))
       innerend(i) = min(nx,int((x0(i)+nfwhminner*xwid(i)-x(1))/xstep))
    enddo
    y = 0.                      !initialise output array
    !! inner
    !$OMP PARALLEL IF ((nx*nlines).gt.1000000)
    !$OMP DO 
    do j=1,nlines
       do i=innerbeg(j),innerend(j)
          y(i) = y(i) + yint(j)*xwid(j)/6.283185307179586/((x(i)-x0(j))**2+xwid(j)**2/4.) !lorentzian
       end do
    end do
    !$OMP END DO
    !$OMP END PARALLEL   
    !! high energy wing -- merging distant lines
    !! array of indices to facilitate shifting
    tx0 = x0
    tyint = yint*xwid/6.283185307179586
    tlines = innerend
    call argsort_int(tlines,ilines,1,nlines)
    kbeg = 1
    do i=1,nx                   !loop through x domain
       kprev = 0                !track previous line to potentially merge with
       jprev = 0        !track previous line to potentially merge with
       do k=kbeg,nlines !index array index
          j = ilines(k)                            !actuall line index
          if (i.le.innerend(j)) exit !! inner or left of line, not started right wing yet
          y(i) = y(i) + tyint(j)/((x(i)-x0(j))**2) !approx lorentzian -- hyperbolum**2
          !! test if a merge with previous line is justified
          if (jprev.gt.0) then
             if (abs((x(i)-tx0(j))/(tx0(j)-tx0(jprev))).gt.nmerge) then
                tyint(j) = tyint(j) + tyint(jprev) !sum strength
                tx0(j) = 0.5*(tx0(j)+tx0(jprev))   !mean position
                !! shift array of indices to remove merged line
                kbeg = kbeg+1
                do l=kprev,kbeg,-1
                   ilines(l) = ilines(l-1)
                end do
             end if
          end if
          kprev = k
          jprev = ilines(kprev)
       end do
    end do
    !! low energy wing -- merging distant lines
    tx0 = x0
    tyint = yint*xwid/6.283185307179586
    call argsort_int(-innerbeg,ilines,1,nlines)
    kbeg = 1
    linemask = .false.
    do i=nx,1,-1                   !loop through x domain
       kprev = 0                !track previous line to potentially merge with
       jprev = 0        !track previous line to potentially merge with
       do k=kbeg,nlines !index array index
          j = ilines(k)                            !actuall line index
          if (i.ge.innerbeg(j)) exit !! inner or left of line, not started right wing yet
          y(i) = y(i) + tyint(j)/((x(i)-x0(j))**2) !approx lorentzian -- hyperbolum**2
          !! test if a merge with previous line is justified
          if ((jprev.gt.0).and.((abs((x(i)-tx0(j))/(tx0(j)-tx0(jprev))).gt.nmerge))) then
             tx0(j) = 0.5*(tx0(j)+tx0(jprev))   !mean position
             tyint(j) = tyint(j) + tyint(jprev) !sum strength
             !! shift array of indices to remove merged line
             kbeg = kbeg+1
             do l=kprev,kbeg,-1
                ilines(l) = ilines(l-1)
             end do
          end if
          kprev = k
          jprev = ilines(kprev)
       end do
    end do
  end subroutine calculate_lorentzian_spectrum_approximate_wings

  ! subroutine convolve_with_doppler(mass,temperature,nfwhm,x,yin,yout,nx)
  ! !! Convolve with Doppler broadening, accurate but approx widths,
  ! !! on regular, monotonic grid.
  ! integer*8,intent(in):: nx   !length of freuency array 
  ! real*8 :: xstep  !regula step in frequneny scale
  ! real*8,intent(in),dimension(nx) :: x       !frequencies (cm-1)
  ! real*8,intent(in),dimension(nx) :: yin     !input spectrum
  ! real*8,intent(inout),dimension(nx) :: yout !Doppler broadened spectrum
  ! real*8,intent(in) :: mass                  !amu
  ! real*8,intent(in) :: temperature           !K
  ! real*8,intent(in) :: nfwhm                 !Number of Doppler FWHMs to include
  ! real*8,dimension(:),allocatable :: yg      !Gaussian coefficients
  ! integer*8 :: ng,ngprevious         !length of Gaussian coefficient array
  ! real*8 :: gfwhm         !Doppler width cm-1 FWHM
  ! real*8 :: dopplerfactor !Doppler width with frequency (cm-1) factored out
  ! integer*8 :: j,k,l
  ! real*8 :: p,q
  ! xstep = (x(nx)-x(1))/(size(x)-1)
  ! dopplerfactor = 2.*6.331e-8*sqrt(temperature*32./mass)
  ! ngprevious = 0              !monitor when Doppler width changes significantly
  ! allocate(yg(1))             !allocated properly in loop
  ! l = int(dopplerfactor*x(nx)*nfwhm/xstep) !maximum doppler extent (in grid points, corresponiding to highest frequency
  ! yout(1:l) = 0.                         !outside this set to zero
  ! yout(nx-l:nx) = 0.                     !outside this set to zero
  ! do j=1+l,nx-l                          !loop through all frequencies
  ! gfwhm = dopplerfactor*x(j)          !Doppler width a this frequency
  ! ng = int(gfwhm*nfwhm/xstep)         !how many points to inlcude this in convolution
  ! if (ng.ne.ngprevious) then          !if ng has changed, then recomputed Doppler coefficients
  ! ngprevious = ng
  ! deallocate(yg)
  ! allocate(yg(ng))
  ! p = -2.772588722239781/gfwhm**2 ! precompute for speed
  ! yg(1) = 1.                      !center point
  ! q = yg(1)                !used to normalise Gaussian coefficients
  ! do k=2,ng                !left and right sides, only computed once
  ! yg(k) = exp(p*((k-1)*xstep)**2)
  ! q = q + yg(k)*2    
  ! end do
  ! do k=1,ng             !normalise 
  ! yg(k) = yg(k)/q
  ! end do
  ! end if
  ! !! perform the convolution
  ! yout(j) = yg(1)*yin(j)   !center point
  ! q =0.
  ! do k=2,ng                 !left and right side points
  ! yout(j) = yout(j) + yg(k)*yin(j-(k-1)) + yg(k)*yin(j+(k-1))
  ! q = q+1
  ! end do
  ! end do
  ! end subroutine convolve_with_doppler

  subroutine convolve_with_doppler(mass,temperature,nfwhm,x,yin,yout,nx)
    !! Convolve with Doppler broadening, accurate but approx widths,
    !! on regular, monotonic grid.
    integer*8,intent(in):: nx   !length of freuency array 
    real*8 :: xstep  !regula step in frequneny scale
    real*8,intent(in),dimension(nx) :: x       !frequencies (cm-1)
    real*8,intent(in),dimension(nx) :: yin     !input spectrum
    real*8,intent(inout),dimension(nx) :: yout !Doppler broadened spectrum
    real*8,intent(in) :: mass                  !amu
    real*8,intent(in) :: temperature           !K
    real*8,intent(in) :: nfwhm                 !Number of Doppler FWHMs to include
    real*8,dimension(:),allocatable :: yg      !Gaussian coefficients
    integer*8 :: ng,ngprevious         !length of Gaussian coefficient array
    real*8 :: gfwhm         !Doppler width cm-1 FWHM
    real*8 :: dopplerfactor !Doppler width with frequency (cm-1) factored out
    integer*8 :: j,k,l
    real*8 :: p,q
    xstep = (x(nx)-x(1))/(size(x)-1)
    dopplerfactor = 2.*6.331e-8*sqrt(temperature*32./mass)
    ngprevious = 0              !monitor when Doppler width changes significantly
    allocate(yg(1))             !allocated properly in loop
    l = int(dopplerfactor*x(nx)*nfwhm/xstep) !maximum doppler extent (in grid points, corresponiding to highest frequency
    yout(1:l) = 0.                         !outside this set to zero
    yout(nx-l:nx) = 0.                     !outside this set to zero
    do j=1,nx                          !loop through all frequencies
       gfwhm = dopplerfactor*x(j)          !Doppler width a this frequency
       ng = int(gfwhm*nfwhm/xstep)         !how many points to inlcude this in convolution
       if (ng.ne.ngprevious) then          !if ng has changed, then recomputed Doppler coefficients
          ngprevious = ng
          deallocate(yg)
          allocate(yg(ng))
          p = -2.772588722239781/gfwhm**2 ! precompute for speed
          yg(1) = 1.                      !center point
          q = yg(1)                !used to normalise Gaussian coefficients
          do k=2,ng                !left and right sides, only computed once
             yg(k) = exp(p*((k-1)*xstep)**2)
             q = q + yg(k)*2.
          end do
          do k=1,ng             !normalise 
             yg(k) = yg(k)/q
          end do
       end if
       !! perform the convolution -- points outside the data range are not included
       yout(j) = yg(1)*yin(j)    !center point
       do k=2,ng                 !left and right side points
          l = (j-(k-1))
          if (l.gt.0)  yout(j) = yout(j) + yg(k)*yin(l)
          l = (j+(k-1))
          if (l.lt.(nx+1)) yout(j) = yout(j) + yg(k)*yin(l)
       end do
    end do
  end subroutine convolve_with_doppler

  !! Convolves a gaussian profile of given fwhm
  !! Requires a data input file [ww(cm-1),xs] and outputs
  !! on a new grid spacing with range the same as original.
  !!
  !! The convolution is done recursively where neighbouring points in the input
  !! data file are used to define a linear interpolation that can be
  !! analytically convolved with a gaussian using the following formulas:
  !! 
  !! gaussian form: f(x)=a*exp(-b*x^2),
  !! linear form: g(x)=c+d*x over limited range [x1,x2] otherwise zero
  !!
  !! Then using the identities:
  !! \int x*exp(-x^2) dx = 1/2*exp(-x^2)
  !! \int_0^x exp*-x'^2 dx' = sqrt(pi/4)*erf(x)
  !!
  !! The final convolved integral is:
  !! [f(x)*g(x)] = sqrt(pi/4/b)*a*(c+d*x)*(erf(sqrt(b)*(x-x1))-erf(sqrt(b)*(x-x2)))
  !!             + a*d/2/b*(exp(-b*(x-x2)^2)-exp(-b*(x-x1)^2))
  !!
  !! Derivation given in Journal IV pg 43
  !!
  !! This is based on an earlier version of convolve_doppler that used a stepwise
  !! rather than linear approximation
  !!
  !! 2008-03-19T14:10:45+1100, Alan Heays
  !! Based on convolve_doppler.f90 - just changed fwhm definition and inputs
  ! subroutine convolve_with_doppler_irregular_grid(xin,yin,nin,xout,yout,nout,fwhm_without_energy,dxout) 
  subroutine convolve_with_doppler_irregular_grid(xin,yin,nin,xout,yout,nout,fwhm_without_energy) 
    integer :: i
    real*8 :: a,b,c,d,p,q,r,s,u,v
    integer :: iout        !range of output arrays currently in use
    integer :: iin            !the current position o reading input data
    integer, intent(in) :: nin
    integer, intent(in) :: nout
    real*8, intent(in), dimension(nout) :: xout
    real*8, intent(inout), dimension(nout) :: yout
    real*8, intent(in),  dimension(nin) :: xin,yin
    real*8, intent(in) :: fwhm_without_energy
    real*8  :: fwhm
    real*8  :: maxdx
    !! maximum range of gaussian tail considered
    maxdx = fwhm_without_energy*xin(nin)*6.0
    !! initialise output xout and yout scale
    yout = 0.
    iin = 1
    iout = 1
    do while (iin.lt.nin) !until end of input data
       !! calculate coefficients of gaussian and linear functions to be convolved together
       !! uses mean energy of input xin(iin) xin(iin+1) for doppler with, more accurately should
       !! probably be output energy xout(i) but then would have to be recalculated at every
       !! step in loop below.
       fwhm = fwhm_without_energy*xin(iin) !Doppler full-width-half maximum
       a = 0.939437278/fwhm
       b = 2.772588722/(fwhm**2.0)
       d = (yin(iin+1)-yin(iin))/(xin(iin+1)-xin(iin))
       c = yin(iin) - d*xin(iin)
       !! to avoid too much duplication of calculation in loop
       p = a*dsqrt(3.141592654/4.0/b)
       q = a*d/2.0/b
       !! loop through output points doing recursive convolution
       do i=iout,nout
          !! end loop if moved out of maxdx range of x
          if ((xout(i)-xin(iin)).gt.maxdx) exit
          !! move iout if out of maxdx range
          if ((xin(iin)-xout(i)).gt.maxdx) then
             iout = i+1
             cycle
          end if
          !! otherwise add new contribution from yin
          u = dsqrt(b)*(xout(i)-xin(iin))
          v = dsqrt(b)*(xout(i)-xin(iin+1))
          r = p*(c+d*xout(i))*(derf(u) - derf(v))
          s = q*(dexp(-u**2.0) - dexp(-v**2.0))        
          yout(i) = yout(i) + r + s
       end do
       !! next input data point
       iin = iin+1
    end do
  end subroutine convolve_with_doppler_irregular_grid

  !! Return indices of x (i0,i1) which bracket the points x0 and x1 in
  !! sorted array x. ACTUALLY THIS IS NOT COMPLETELY ACCURATE -- MIGTH
  !! MISS BOUNDS BY ONE OR TWO POINTS.
  subroutine find_in_range_sorted(x,n,x0,x1,i0,i1)
     integer, intent(inout) :: n
     integer, intent(inout):: i0,i1
     real*8, intent(inout) :: x(n),x0,x1
     integer :: i,j,k
     if ((x(1).gt.x1).or.(x(n).lt.x0)) then
        !! trivial case not match
        i0 = -1
        i1 = -1
     else
        if (x0.lt.x(1)) then
           !! another trival case
           i0 = 1
        else
           !! bisect downwards looking for bound of lower limit
           i = 1
           j = n
           do while ((j-i).gt.2)
              ! if (l.gt.1000) then
              ! write(*,*) "safety stop"
              ! end if
              if (x(j).gt.x0) then
                 j = (i+j)/2
              else if (x(j).lt.x0) then
                 k = i
                 i = j
                 j = 2*j-k
                 if (j.gt.n) j = n
                 ! j = 2*j-k-1
              end if
           end do
           i0 = j
        end if
        if (x1.gt.x(n)) then
           !! another trival case
           i1 = n
        else
           !! bisect upwardslooking for bound of upper limit
           i = 1
           j = n
           do while ((j-i).gt.2)
              ! if (l.gt.1000) then
              ! write(*,*) "safety stop2"
              ! end if
              if (x(i).lt.x1) then
                 i = (i+j)/2
              else if (x(i).gt.x1) then
                 k = j
                 j = i
                 i = 2*i-k
                 if (i.lt.1) i = 1
                 ! i = 2*i-k+1
              end if
           end do
           i1 = i
        end if
     end if
   end subroutine find_in_range_sorted

   !! Convolves a gaussian profile of given fwhm
   !! Requires a data input file [ww(cm-1),xs] and outputs
   !! on a new grid spacing with range the same as original.
   !!
   !! The convolution is done recursively where neighbouring points in the input
   !! data file are used to define a linear interpolation that can be
   !! analytically convolved with a gaussian using the following formulas:
   !! 
   !! gaussian form: f(x)=a*exp(-b*x^2),
   !! linear form: g(x)=c+d*x over limited range [x1,x2] otherwise zero
   !!
   !! Then using the identities:
   !! \int x*exp(-x^2) dx = 1/2*exp(-x^2)
   !! \int_0^x exp*-x'^2 dx' = sqrt(pi/4)*erf(x)
   !!
   !! The final convolved integral is:
   !! [f(x)*g(x)] = sqrt(pi/4/b)*a*(c+d*x)*(erf(sqrt(b)*(x-x1))-erf(sqrt(b)*(x-x2)))
   !!             + a*d/2/b*(exp(-b*(x-x2)^2)-exp(-b*(x-x1)^2))
   !!
   !! Derivation given in Journal IV pg 43
   !!
   !! This is based on an earlier version of convolve_doppler that used a stepwise
   !! rather than linear approximation
   !!
   !! 2008-03-19T14:10:45+1100, Alan Heays
   !! Based on convolve_doppler.f90 - just changed fwhm definition and inputs
   subroutine convolve_with_gaussian(xin,yin,nin,xout,yout,nout,fwhm) 
     integer :: i
     real*8 :: a,b,c,d,p,q,r,s,u,v
     integer :: iout        !range of output arrays currently in use
     integer :: iin            !the current position o reading input data
     integer, intent(inout) :: nin
     integer, intent(inout) :: nout
     real*8, intent(inout), dimension(nout) :: xout,yout
     real*8, intent(inout),  dimension(nin) :: xin,yin
     real*8, intent(inout) :: fwhm
     real*8  :: maxdx
     !! maximum range of gaussian tail considered
     maxdx = fwhm*6.0
     !! initialise output xout and yout scale
     iout = 1
     iin = 1
     yout = 0.
     !! main loop
     do while (iin.lt.nin) !until end of input data
        !! haven't reached output data yet
        if ((xout(1)-xin(iin)).gt.maxdx) then
           cycle
        end if
        !! gone past output data
        if ((xin(iin)-xout(nout)).gt.maxdx) then
           exit
        end if
        !! calculate coefficients of gaussian and linear functions to be convolved together
        !! uses mean energy of input xin(iin) xin(iin+1) for doppler with, more accurately should
        !! probably be output energy xout(i) but then would have to be recalculated at every
        !! step in loop below.
        a = 0.939437278/fwhm
        b = 2.772588722/(fwhm**2.0)
        d = (yin(iin+1)-yin(iin))/(xin(iin+1)-xin(iin))
        c = yin(iin) - d*xin(iin)
        !! to avoid too much duplication of calculation in loop
        p = a*dsqrt(3.141592654/4.0/b) ;  q = a*d/2.0/b
        !! loop through output points doing recursive convolution
        do i=iout,nout
           !! end loop if moved out of maxdx range of x
           if ((xout(i)-xin(iin)).gt.maxdx) then
              exit
           end if
           !! move iout if out of maxdx range
           if ((xin(iin)-xout(i)).gt.maxdx) then
              iout = i+1
              cycle
           end if
           !! otherwise add new contribution from yin
           u = dsqrt(b)*(xout(i)-xin(iin))
           v = dsqrt(b)*(xout(i)-xin(iin+1))
           r = p*(c+d*xout(i))*(derf(u) - derf(v))
           s = q*(dexp(-u**2.0) - dexp(-v**2.0))        
           yout(i) = yout(i) + r + s

        end do
        !! next input data point
        iin = iin+1
     end do
   end subroutine convolve_with_gaussian

   subroutine findin_sorted(x,y,d,i,nx,ny)
     !! Returns indices of y that match values in x. Assumes both x and y
     !! are sorted. Only works on floats. Returns as zero-indexed
     !! array. Unfound values of x are indexed as -1.
     real*8, intent(inout) :: x(nx),y(ny) !input arrays
     integer*8, intent(inout) :: nx,ny      !length of input arrsy
     real*8, intent(inout) :: d          !tolerance for equality
     integer*8, intent(inout):: i(nx)       !output index array
     integer*8 :: ix,iy       
     iy = 1
     xloop: do ix=1,nx           ! look for integer of equality in x
        yloop: do while (.true.) ! increase y until x is found or exceeded
           ! if (iy.ge.ny) exit xloop ! out of bounds of y - no more data
           ! if (y(iy).gt.(x(ix)+d)) cycle xloop ! y exceeds x - nothing for this x, try the next
           if ((iy.gt.ny).or.(y(iy).gt.(x(ix)+d))) then !out of data or x not found
              i(1) = -1       ! a hack of an error code
              return
           end if
           !! equal x found, save index and move to next x
           equality_found: if (y(iy).gt.(x(ix)-d)) then
              i(ix) = iy
              cycle xloop
           end if equality_found
           iy = iy + 1             ! increase y
        end do yloop
     end do xloop
     i = i-1                       !return as zero-indexed array
   end subroutine findin_sorted

   !! Returns the inverse of a matrix calculated by finding the LU
   !! decomposition.  Depends on LAPACK.
   !! subroutine inv(A,Ainv,n)
   subroutine invert_matrix(A,Ainv,n)
     integer :: n, info
     real*8, dimension(n,n), intent(inout) :: A, Ainv
     real*8, dimension(n) :: work  ! work array for LAPACK
     integer, dimension(n) :: ipiv   ! pivot indices
     external DGETRF   ! External procedures defined in LAPACK
     external DGETRI   ! External procedures defined in LAPACK
     Ainv = A ! Store A in Ainv to prevent it from being overwritten by LAPACK
     call DGETRF(n, n, Ainv, n, ipiv, info) ! DGETRF computes an LU factorization of a general M-by-N matrix A using partial pivoting with row interchanges.
     if (info /= 0) then
        stop 'Matrix is numerically singular!'
     end if
     call DGETRI(n, Ainv, n, ipiv, work, n, info) ! DGETRI computes the inverse of a matrix using the LU factorization computed by DGETRF.
     if (info /= 0) then
        stop 'Matrix inversion failed!'
     end if
   end subroutine invert_matrix

   !! multiple C = AB with dimeions A(m,n), B(n,o), C(m,o)
   subroutine matrix_multiply(A,B,C,m,n,o)
     integer,intent(in) :: m,n,o
     real*8,intent(in):: A(m,n),B(n,o)
     real*8,intent(out):: C(m,o)
     integer :: i,j,k
     C = 0
     do i=1,m
        do j=1,n
           do k=1,n
                 C(i,k) = C(i,k) + A(i,j)*B(j,k)
           end do
        end do
     end do
   end subroutine matrix_multiply

  !! Sorts a list in place. Also returns the reordering order.  Begin
  !! at left_end and right_end indices.
  recursive subroutine quicksort(list,order,left_end,right_end)
    real*8, dimension (:), intent(inout)  :: list
    integer, dimension (:), intent(inout)  :: order
    integer, intent(in) :: left_end, right_end
    integer             :: i, j, itemp
    real*8                :: reference, temp
    integer, parameter  :: max_simple_sort_size = 6
    if (right_end < left_end + max_simple_sort_size) then
       ! use interchange sort for small lists
       do i = left_end, right_end - 1
          do j = i+1, right_end
             if (list(i) > list(j)) then
                temp = list(i); list(i) = list(j); list(j) = temp
                itemp = order(i); order(i) = order(j); order(j) = itemp
             end if
          end do
       end do
    else
       ! use partition ("quick") sort
       reference = list((left_end + right_end)/2)
       i = left_end - 1; j = right_end + 1
       do
          ! scan list from left end until element >= reference is found
          do
             i = i + 1
             if (list(i) >= reference) exit
          end do
          ! scan list from right end until element <= reference is found
          do
             j = j - 1
             if (list(j) <= reference) exit
          end do
          if (i < j) then
             ! swap two out-of-order elements
             temp = list(i); list(i) = list(j); list(j) = temp
             itemp = order(i); order(i) = order(j); order(j) = itemp
          else if (i == j) then
             i = i + 1
             exit
          else
             exit
          end if
       end do
       if (left_end < j) call quicksort(list,order,left_end, j)
       if (i < right_end) call quicksort(list,order,i, right_end)
    end if
  end subroutine quicksort

  !! I forget what this does.
  recursive subroutine argsort_int(list,order,left_end,right_end)
    integer, dimension (:), intent(in)  :: list
    integer, allocatable,dimension (:)   :: list_copy
    integer, dimension (:), intent(out)  :: order
    integer, intent(in) :: left_end, right_end
    integer             :: i
    allocate(list_copy(size(list)))
    list_copy = list
    do i=left_end,right_end
       order(i) = i
    end do
    call quicksort_int(list_copy,order,left_end,right_end)
  end subroutine argsort_int

  !! I forget what this does.
  recursive subroutine quicksort_int(list,order,left_end,right_end)
    integer, dimension (:), intent(inout)  :: list
    integer, dimension (:), intent(inout)  :: order
    integer, intent(in) :: left_end, right_end
    integer             :: i, j, itemp
    integer                :: reference, temp
    integer, parameter  :: max_simple_sort_size = 6
    if (right_end < left_end + max_simple_sort_size) then
       ! use interchange sort for small lists
       do i = left_end, right_end - 1
          do j = i+1, right_end
             if (list(i) > list(j)) then
                temp = list(i); list(i) = list(j); list(j) = temp
                itemp = order(i); order(i) = order(j); order(j) = itemp
             end if
          end do
       end do
    else
       ! use partition ("quick") sort
       reference = list((left_end + right_end)/2)
       i = left_end - 1; j = right_end + 1
       do
          ! scan list from left end until element >= reference is found
          do
             i = i + 1
             if (list(i) >= reference) exit
          end do
          ! scan list from right end until element <= reference is found
          do
             j = j - 1
             if (list(j) <= reference) exit
          end do
          if (i < j) then
             ! swap two out-of-order elements
             temp = list(i); list(i) = list(j); list(j) = temp
             itemp = order(i); order(i) = order(j); order(j) = itemp
          else if (i == j) then
             i = i + 1
             exit
          else
             exit
          end if
       end do
       if (left_end < j) call quicksort_int(list,order,left_end, j)
       if (i < right_end) call quicksort_int(list,order,i, right_end)
    end if
  end subroutine quicksort_int

  !! Compute integral of y using trapezium rule assuming y on a
  !! regular grid of step dx.
  subroutine integrate_trapz_uniform_grid(y,dx,yint,ny)
    real*8, intent(inout),dimension(ny) :: y
    real*8, intent(in) :: dx
    real*8, intent(inout) :: yint !the result
    integer, intent(in) :: ny
    integer :: i
    yint = 0.
    do i=2,(ny-1)
       yint = yint + y(i)
    end do
    yint = yint*2.0d0 + y(1) + y(ny)
    yint = yint*dx/2.0d0
  end subroutine integrate_trapz_uniform_grid

  !! Compute integral of y using trapezium rule assuming y on a
  !! regular grid of step dx. Uses OPENMP if available.
  subroutine integrate_trapz_uniform_grid_two_dimensional(y,dx,yint,ny1,ny2)
    real*8, intent(inout),dimension(ny1,ny2) :: y
    real*8, intent(in) :: dx
    real*8, intent(inout),dimension(ny2) :: yint !the result
    integer, intent(in) :: ny1,ny2
    integer :: i1,i2
    !! perhaps could be worht parallelising if a big enough integration
    do i2=1,ny2
       yint(i2) = 0.
       do i1=2,(ny1-1)
          yint(i2) = yint(i2) + y(i1,i2)
       end do
       yint(i2) = yint(i2)*2.0d0 + y(1,i2) + y(ny1,i2)
       yint(i2) = yint(i2)*dx/2.0d0
    end do
  end subroutine integrate_trapz_uniform_grid_two_dimensional
  
  !! Compute cross correlation between two arrays x and y. Width of
  !! correlation is limited to iwidth, and maximum shift of cross
  !! correlation. NO ERROR CHECKING FOR SEGMENTATION FAULT. Attempts
  !! to use OMP for parallel computation
  subroutine cross_correlate(x,y,c,imax_shift,iwidth,nx,ny,nc)
    real*8, intent(in),dimension(nx) :: x
    real*8, intent(in),dimension(ny) :: y
    real*8, intent(inout),dimension(nc) :: c
    integer, intent(in) :: nx,ny,nc
    integer, intent(in) :: imax_shift,iwidth
    integer :: i,j,imidx,imidy
    imidx = (nx-1)/2
    imidy = (ny-1)/2
    !$OMP PARALLEL
    !$OMP DO 
    do i = -imax_shift,imax_shift
       c(i+imax_shift+1) = 0.0
       do j = -iwidth,iwidth
          c(i+imax_shift+1) = c(i+imax_shift+1) + x(j+imidx)*y(j+imidy+i)
       end do
    end do
    !$OMP END DO
    !$OMP END PARALLEL   
  end subroutine cross_correlate


  !! Used in spectrum.py.  Take array yin which is interpolated but
  !! not extrapolated by an odd factor.  Compute the average of the
  !! window of points around each interpolated point.  Reversing the
  !! interpolation with averaging.
  subroutine uninterpolate_with_averaging(yin,yout,factor,nin,nout)
    real*8, intent(in),dimension(nin) :: yin
    real*8, intent(inout),dimension(nout) :: yout
    integer, intent(in) :: nin,nout,factor
    integer :: i,j,k,l,m
    k = (factor-1)/2            !factor must be odd
    do i = 1,nout
       yout(i) = 0
       l = 0                    !number of summed points
       m = 1+(i-1)*factor       !fancy indexing
       do j = max(1,m-k),min(nin,m+k)
          yout(i) = yout(i) + yin(j)
          l = l + 1
       end do
       yout(i) = yout(i) / l
    end do
  end subroutine uninterpolate_with_averaging
  
  !! bin data in xin into bins of width nbin, save in xout
  subroutine bin_data(xin,xout,nbin,nin,nout)
    real*8, intent(in),dimension(nin) :: xin
    real*8, intent(inout),dimension(nout) :: xout
    integer, intent(in) :: nbin,nin,nout
    integer :: i,j,k
    do i = 1,nout
       xout(i) = 0
       k = 1+(i-1)*nbin      
       do j = k,k+(nbin-1)
          xout(i) = xout(i) + xin(j)
       end do
    end do
  end subroutine bin_data

  !! a little bit faster than x = np.multiply(x,y)
  subroutine in_place_array_multiplication(x,y,n)
    real*8, intent(inout),dimension(n) :: x
    real*8, intent(inout),dimension(n) :: y
    integer, intent(in) :: n
    x = x*y
  end subroutine in_place_array_multiplication
  

end module fortran_tools

